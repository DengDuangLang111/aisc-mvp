import { Test, TestingModule } from '@nestjs/testing';
import { AnalyticsMiddleware } from './analytics.middleware';
import { AnalyticsService } from './analytics.service';
import { Request, Response } from 'express';

describe('AnalyticsMiddleware', () => {
  let middleware: AnalyticsMiddleware;
  let analyticsService: any;

  beforeEach(async () => {
    const mockAnalyticsService = {
      logApiUsage: jest.fn().mockResolvedValue(undefined),
      trackEvent: jest.fn().mockResolvedValue(undefined),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AnalyticsMiddleware,
        {
          provide: AnalyticsService,
          useValue: mockAnalyticsService,
        },
      ],
    }).compile();

    middleware = module.get<AnalyticsMiddleware>(AnalyticsMiddleware);
    analyticsService = module.get(AnalyticsService);
  });

  it('should be defined', () => {
    expect(middleware).toBeDefined();
  });

  describe('use', () => {
    let mockRequest: Partial<Request>;
    let mockResponse: Partial<Response>;
    let nextFunction: jest.Mock;

    beforeEach(() => {
      mockRequest = {
        method: 'GET',
        path: '/api/test',
        ip: '127.0.0.1',
        socket: {
          remoteAddress: '127.0.0.1',
        },
        get: jest.fn((header: string) => {
          if (header === 'content-length') return '100';
          return undefined;
        }),
      } as any;
      mockResponse = {
        statusCode: 200,
        on: jest.fn((event: string, callback: Function) => {
          if (event === 'finish') {
            // Simulate response finish
            setTimeout(() => callback(), 0);
          }
          return mockResponse;
        }),
        get: jest.fn((header: string) => {
          if (header === 'content-length') return '500';
          return undefined;
        }),
      };
      nextFunction = jest.fn();
    });

    it('should call next() immediately', async () => {
      middleware.use(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction,
      );

      expect(nextFunction).toHaveBeenCalled();
    });

    it('should register finish event listener', async () => {
      middleware.use(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction,
      );

      expect(mockResponse.on).toHaveBeenCalledWith('finish', expect.any(Function));
    });

    it('should track API usage on response finish', async () => {
      await new Promise<void>((resolve) => {
        mockResponse.on = jest.fn((event: string, callback: Function) => {
          if (event === 'finish') {
            callback();
            resolve();
          }
        });

        middleware.use(
          mockRequest as Request,
          mockResponse as Response,
          nextFunction,
        );
      });

      expect(analyticsService.logApiUsage).toHaveBeenCalledWith({
        userId: undefined,
        endpoint: '/api/test',
        method: 'GET',
        statusCode: 200,
        responseTimeMs: expect.any(Number),
        requestSizeBytes: 100,
        responseSizeBytes: 500,
      });
    });

    it('should handle missing content-length header', async () => {
      mockRequest.get = jest.fn(() => undefined);

      await new Promise<void>((resolve) => {
        mockResponse.on = jest.fn((event: string, callback: Function) => {
          if (event === 'finish') {
            callback();
            resolve();
          }
        });

        middleware.use(
          mockRequest as Request,
          mockResponse as Response,
          nextFunction,
        );
      });

      expect(analyticsService.logApiUsage).toHaveBeenCalledWith(
        expect.objectContaining({
          requestSizeBytes: 0,
        }),
      );
    });

    it('should handle error status codes', async () => {
      mockResponse.statusCode = 500;

      await new Promise<void>((resolve) => {
        mockResponse.on = jest.fn((event: string, callback: Function) => {
          if (event === 'finish') {
            callback();
            resolve();
          }
        });

        middleware.use(
          mockRequest as Request,
          mockResponse as Response,
          nextFunction,
        );
      });

      expect(analyticsService.logApiUsage).toHaveBeenCalledWith(
        expect.objectContaining({
          statusCode: 500,
        }),
      );
    });

    it('should handle different HTTP methods', async () => {
      mockRequest.method = 'POST';

      await new Promise<void>((resolve) => {
        mockResponse.on = jest.fn((event: string, callback: Function) => {
          if (event === 'finish') {
            callback();
            resolve();
          }
        });

        middleware.use(
          mockRequest as Request,
          mockResponse as Response,
          nextFunction,
        );
      });

      expect(analyticsService.logApiUsage).toHaveBeenCalledWith(
        expect.objectContaining({
          method: 'POST',
        }),
      );
    });
  });
});
